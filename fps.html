<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <title>Modern Web FPS Arena</title>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@500&family=Rajdhani:wght@400;700&display=swap" rel="stylesheet">
    <style>
        body { margin: 0; overflow: hidden; background-color: #0d1117; font-family: 'Rajdhani', sans-serif; color: #fff; }

        /* General UI Container */
        #ui-container {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; z-index: 10;
            display: flex; flex-direction: column;
            justify-content: space-between;
        }

        /* Top Bar */
        #top-bar {
            display: flex; justify-content: space-between; padding: 20px;
            font-family: 'Orbitron', sans-serif; font-size: 2em;
            text-shadow: 0 0 5px rgba(0,255,0,0.5);
            background: linear-gradient(to bottom, rgba(0,0,0,0.5), rgba(0,0,0,0));
        }
        #score-display span, #enemy-display span { color: #00ff00; }
        #health-bar-container { width: 200px; height: 30px; background: rgba(0,0,0,0.7); border: 2px solid #00ff00; border-radius: 5px; overflow: hidden; }
        #health-bar { width: 100%; height: 100%; background: #00ff00; transition: width 0.2s ease-out; }

        /* Crosshair */
        #crosshair {
            position: absolute; top: 50%; left: 50%;
            width: 2px; height: 2px;
            background: #00ff00; /* Center dot */
            transform: translate(-50%, -50%);
            pointer-events: none;
            z-index: 10;
        }
        #crosshair::before, #crosshair::after {
            content: ''; position: absolute; background: #00ff00;
        }
        #crosshair::before { /* Horizontal lines */
            width: 20px; height: 2px; top: 0; left: -9px;
            transform: translateX(-50%);
        }
        #crosshair::after { /* Vertical lines */
            height: 20px; width: 2px; left: 0; top: -9px;
            transform: translateY(-50%);
        }

        /* Hit Marker */
        #hit-marker {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: #ff0000; font-weight: bold; font-size: 3em; opacity: 0; pointer-events: none;
            transition: opacity 0.1s; text-shadow: 0 0 10px rgba(255,0,0,0.7);
            font-family: 'Orbitron', sans-serif;
        }

        /* Blocker (Start Screen) */
        #blocker {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background-color: rgba(0,0,0,0.8);
            display: flex; justify-content: center; align-items: center;
            z-index: 20;
            backdrop-filter: blur(5px);
        }
        #instructions {
            color: #00ff00; text-align: center; cursor: pointer;
            font-size: 2.5em; background: rgba(0,0,0,0.7); padding: 50px;
            border-radius: 15px; border: 3px solid #00ff00;
            box-shadow: 0 0 20px rgba(0,255,0,0.5);
            font-family: 'Orbitron', sans-serif;
            transition: all 0.3s ease;
        }
        #instructions:hover {
            background: rgba(0,255,0,0.1);
            box-shadow: 0 0 30px rgba(0,255,0,0.8);
            transform: scale(1.02);
        }
        #instructions p { font-size: 0.6em; line-height: 1.5; color: #eee; margin-top: 20px; font-family: 'Rajdhani', sans-serif;}
        #instructions span { display: block; margin-bottom: 15px;}

        /* Kill Feed */
        #kill-feed {
            position: absolute; top: 120px; right: 20px;
            width: 300px; max-height: 400px;
            overflow: hidden;
            display: flex; flex-direction: column;
            align-items: flex-end;
            pointer-events: none;
            font-family: 'Rajdhani', sans-serif;
        }
        .kill-message {
            background: rgba(0,0,0,0.7);
            color: #00ff00;
            padding: 8px 15px;
            margin-bottom: 5px;
            border-radius: 5px;
            font-size: 1.1em;
            animation: fadeOut 3s forwards;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            box-shadow: 0 0 5px rgba(0,255,0,0.3);
        }
        @keyframes fadeOut {
            0% { opacity: 1; transform: translateX(0); }
            80% { opacity: 1; transform: translateX(0); }
            100% { opacity: 0; transform: translateX(100%); }
        }

        /* Audio element for sound effects */
        #sfx-audio { display: none; }

    </style>
</head>
<body>
    <div id="ui-container">
        <div id="top-bar">
            <div id="score-display">점수: <span id="score">0</span></div>
            <div id="health-bar-container">
                <div id="health-bar"></div>
            </div>
            <div id="enemy-display">적: <span id="enemy-count">0</span></div>
        </div>
        <div id="kill-feed"></div>
    </div>

    <div id="crosshair"></div>
    <div id="blocker">
        <div id="instructions">
            <span>클릭하여 게임 시작</span>
            <p>
                (W, A, S, D) = 이동<br/>
                (SPACE) = 점프<br/>
                (마우스) = 시점 전환<br/>
                (클릭) = 발사
            </p>
        </div>
    </div>
    <div id="hit-marker">HIT</div>

    <audio id="shoot-sfx" src="https://www.soundjay.com/weapons/sounds/shotgun-blast-2.mp3" preload="auto"></audio>
    <audio id="hit-sfx" src="https://www.soundjay.com/misc/sounds/pew-2.mp3" preload="auto"></audio>
    <audio id="explode-sfx" src="https://www.soundjay.com/explosions/sounds/bomb-explosion-1.mp3" preload="auto"></audio>
    
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';

        // --- 1. 기본 설정 (Scene, Camera, Renderer) ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x1a2a3a); // 더 어둡고 모던한 하늘색
        scene.fog = new THREE.Fog(0x1a2a3a, 10, 500); // 안개 거리 조정

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000); // near clipping plane 0.1로 조정
        camera.position.set(0, 50, 0); // 시작 위치를 맵 중앙 위로 조정

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap; // 부드러운 그림자
        document.body.appendChild(renderer.domElement);

        // --- 2. 조명 설정 ---
        const ambientLight = new THREE.AmbientLight(0x404040, 0.5); // 약한 앰비언트 라이트
        scene.add(ambientLight);

        const dirLight = new THREE.DirectionalLight(0xffffff, 1.2);
        dirLight.position.set(50, 150, 50); // 광원 위치 조정
        dirLight.castShadow = true;
        dirLight.shadow.mapSize.width = 2048; // 그림자 해상도
        dirLight.shadow.mapSize.height = 2048;
        dirLight.shadow.camera.near = 1;
        dirLight.shadow.camera.far = 300;
        dirLight.shadow.camera.left = -100;
        dirLight.shadow.camera.right = 100;
        dirLight.shadow.camera.top = 100;
        dirLight.shadow.camera.bottom = -100;
        scene.add(dirLight);

        // --- 3. 컨트롤러 (PointerLock) ---
        const controls = new PointerLockControls(camera, document.body);
        const blocker = document.getElementById('blocker');
        const instructions = document.getElementById('instructions');

        instructions.addEventListener('click', function () {
            controls.lock();
        });

        controls.addEventListener('lock', function () {
            instructions.style.display = 'none';
            blocker.style.display = 'none';
        });

        controls.addEventListener('unlock', function () {
            blocker.style.display = 'flex';
            instructions.style.display = 'block';
        });

        scene.add(controls.getObject());

        // --- 4. 이동 및 점프 변수 ---
        let moveForward = false;
        let moveBackward = false;
        let moveLeft = false;
        let moveRight = false;
        let canJump = false;

        const velocity = new THREE.Vector3();
        const direction = new THREE.Vector3();
        const playerHeight = 10; // 플레이어 눈 높이

        // 키보드 이벤트 리스너
        const onKeyDown = function (event) {
            switch (event.code) {
                case 'ArrowUp': case 'KeyW': moveForward = true; break;
                case 'ArrowLeft': case 'KeyA': moveLeft = true; break;
                case 'ArrowDown': case 'KeyS': moveBackward = true; break;
                case 'ArrowRight': case 'KeyD': moveRight = true; break;
                case 'Space': if (canJump === true) { velocity.y += 200; canJump = false; } break; // 점프력 조정
            }
        };

        const onKeyUp = function (event) {
            switch (event.code) {
                case 'ArrowUp': case 'KeyW': moveForward = false; break;
                case 'ArrowLeft': case 'KeyA': moveLeft = false; break;
                case 'ArrowDown': case 'KeyS': moveBackward = false; break;
                case 'ArrowRight': case 'KeyD': moveRight = false; break;
            }
        };

        document.addEventListener('keydown', onKeyDown);
        document.addEventListener('keyup', onKeyUp);

        // --- 5. 맵 생성 (미니 아레나) ---
        const objects = []; // 충돌 감지를 위한 모든 맵 오브젝트
        const spawnPoints = []; // 적이 생성될 위치

        function createMap() {
            // 바닥 (더 넓게)
            const floorGeometry = new THREE.PlaneGeometry(300, 300, 1, 1);
            floorGeometry.rotateX(-Math.PI / 2);
            const floorMaterial = new THREE.MeshStandardMaterial({ color: 0x333333, roughness: 0.8, metalness: 0.1 });
            const floor = new THREE.Mesh(floorGeometry, floorMaterial);
            floor.receiveShadow = true;
            scene.add(floor);
            objects.push(floor);

            // 경계 벽 (맵 밖으로 나가지 못하게)
            const wallMaterial = new THREE.MeshStandardMaterial({ color: 0x555555, roughness: 0.6 });
            const wallHeight = 50;

            function addWall(x, y, z, width, depth, rotationY = 0) {
                const wallGeo = new THREE.BoxGeometry(width, wallHeight, depth);
                const wall = new THREE.Mesh(wallGeo, wallMaterial);
                wall.position.set(x, wallHeight / 2, z);
                wall.castShadow = true;
                wall.receiveShadow = true;
                if (rotationY !== 0) wall.rotation.y = rotationY;
                scene.add(wall);
                objects.push(wall);
            }

            addWall(0, 0, -150, 300, 10); // 북
            addWall(0, 0, 150, 300, 10);  // 남
            addWall(-150, 0, 0, 10, 300); // 서
            addWall(150, 0, 0, 10, 300);  // 동

            // 중앙 플랫폼 1
            addWall(0, 20, 0, 60, 60, 0); // (x, y, z, width, depth)
            spawnPoints.push(new THREE.Vector3(0, 20 + playerHeight, 0));

            // 측면 엄폐물
            addWall(-80, 10, -80, 30, 30);
            spawnPoints.push(new THREE.Vector3(-80, 10 + playerHeight, -80));
            addWall(80, 10, 80, 30, 30);
            spawnPoints.push(new THREE.Vector3(80, 10 + playerHeight, 80));

            // 작은 기둥
            addWall(-40, 5, 40, 10, 10);
            addWall(40, 5, -40, 10, 10);

            // 램프 (간단한 경사로)
            const rampGeometry = new THREE.BoxGeometry(20, 10, 40);
            const ramp = new THREE.Mesh(rampGeometry, wallMaterial);
            ramp.position.set(-20, 5, -80);
            ramp.rotation.x = Math.PI / 6; // 경사
            ramp.castShadow = true;
            ramp.receiveShadow = true;
            scene.add(ramp);
            objects.push(ramp);

            // 다른 스폰 포인트들
            spawnPoints.push(new THREE.Vector3(100, playerHeight, 100));
            spawnPoints.push(new THREE.Vector3(-100, playerHeight, -100));
            spawnPoints.push(new THREE.Vector3(0, playerHeight, -100));
            spawnPoints.push(new THREE.Vector3(-100, playerHeight, 0));
        }
        createMap();

        // --- 6. 적(타겟) 시스템 ---
        const enemies = [];
        const enemyGeometry = new THREE.BoxGeometry(15, 15, 15); // 적 크기
        const maxEnemies = 10; // 최대 적 수

        function createEnemy() {
            if (enemies.length >= maxEnemies) return;

            const color = new THREE.Color(0xff0000).getHex(); // 적은 빨간색으로 통일
            const material = new THREE.MeshStandardMaterial({ color: color, emissive: 0x880000, emissiveIntensity: 0.5 }); // 스스로 빛나는 효과
            const enemy = new THREE.Mesh(enemyGeometry, material);
            
            // 스폰 포인트에서 랜덤 위치 선택
            const spawnPoint = spawnPoints[Math.floor(Math.random() * spawnPoints.length)];
            enemy.position.copy(spawnPoint);
            
            enemy.castShadow = true;
            enemy.receiveShadow = true;
            scene.add(enemy);
            enemies.push(enemy);
            updateUI();
        }

        // 초기 적 생성
        for(let i=0; i<5; i++) createEnemy();
        // 일정 시간마다 적 자동 생성
        setInterval(createEnemy, 5000);

        // --- 7. 사격 시스템 (Raycasting) 및 UI ---
        const shootSfx = document.getElementById('shoot-sfx');
        const hitSfx = document.getElementById('hit-sfx');
        const explodeSfx = document.getElementById('explode-sfx');

        const raycaster = new THREE.Raycaster();
        let score = 0;
        let playerHealth = 100; // 임시 체력
        const scoreEl = document.getElementById('score');
        const enemyCountEl = document.getElementById('enemy-count');
        const healthBar = document.getElementById('health-bar');
        const hitMarker = document.getElementById('hit-marker');
        const killFeed = document.getElementById('kill-feed');

        function shoot() {
            if (!controls.isLocked) return;

            // 총소리 재생
            shootSfx.currentTime = 0;
            shootSfx.play();

            // 화면 흔들림 효과
            screenShake(camera, 0.5, 0.1);

            raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);
            const intersects = raycaster.intersectObjects(enemies);

            if (intersects.length > 0) {
                const hitObject = intersects[0].object;
                
                // 적 제거
                scene.remove(hitObject);
                enemies.splice(enemies.indexOf(hitObject), 1);
                
                // 효과 및 점수
                score += 100;
                showHitMarker();
                hitSfx.currentTime = 0;
                hitSfx.play();
                createExplosion(intersects[0].point, hitObject.material.color);
                addKillFeedMessage("적을 처치했습니다!");
                
                updateUI();
            }
        }

        function createBulletTrail() {
            // 총알 궤적은 Three.js Raycaster가 이미 시각적으로 처리하고 있으므로 생략하거나,
            // 더 복잡한 파티클 시스템을 사용할 수 있습니다. 여기서는 간단히 총구 불꽃만 표현합니다.
        }

        function createExplosion(position, color) {
            explodeSfx.currentTime = 0;
            explodeSfx.play();

            const particleCount = 20;
            const particleGeometry = new THREE.SphereGeometry(1, 8, 8); // 구형 파티클
            const particleMaterial = new THREE.MeshBasicMaterial({ color: color, transparent: true, opacity: 1 });

            for (let i = 0; i < particleCount; i++) {
                const particle = new THREE.Mesh(particleGeometry, particleMaterial.clone()); // 각 파티클은 개별 Material
                particle.position.copy(position);
                
                // 랜덤 확산 및 속도
                particle.userData.velocity = new THREE.Vector3(
                    (Math.random() - 0.5) * 50,
                    (Math.random() - 0.5) * 50,
                    (Math.random() - 0.5) * 50
                );
                particle.userData.life = 0.5 + Math.random(); // 수명 (초)
                particle.userData.age = 0;

                scene.add(particle);
                explosions.push(particle);
            }
        }

        const explosions = []; // 활성 폭발 파티클을 관리하는 배열

        function updateExplosions(delta) {
            for (let i = explosions.length - 1; i >= 0; i--) {
                const particle = explosions[i];
                particle.userData.age += delta;

                if (particle.userData.age > particle.userData.life) {
                    scene.remove(particle);
                    explosions.splice(i, 1);
                } else {
                    // 중력 및 이동
                    particle.userData.velocity.y -= 9.8 * 20 * delta; // 파티클 중력
                    particle.position.addScaledVector(particle.userData.velocity, delta);
                    particle.material.opacity = 1 - (particle.userData.age / particle.userData.life); // 투명도 변화
                }
            }
        }

        function showHitMarker() {
            hitMarker.style.opacity = 1;
            setTimeout(() => hitMarker.style.opacity = 0, 200);
        }

        function updateUI() {
            scoreEl.innerText = score;
            enemyCountEl.innerText = enemies.length;
            healthBar.style.width = `${playerHealth}%`;
            healthBar.style.backgroundColor = playerHealth > 50 ? '#00ff00' : (playerHealth > 20 ? '#ffff00' : '#ff0000');
        }

        function addKillFeedMessage(message) {
            const msgElement = document.createElement('div');
            msgElement.className = 'kill-message';
            msgElement.textContent = message;
            killFeed.prepend(msgElement); // 최신 메시지가 위로

            // 5초 후 메시지 삭제 (CSS 애니메이션 완료 후)
            setTimeout(() => {
                killFeed.removeChild(msgElement);
            }, 5000);
        }

        document.addEventListener('mousedown', shoot);

        // --- 8. 화면 흔들림 효과 ---
        let shake = {
            duration: 0,
            intensity: 0,
            elapsed: 0
        };

        function screenShake(targetCamera, duration, intensity) {
            shake.duration = duration;
            shake.intensity = intensity;
            shake.elapsed = 0;
            targetCamera.userData.originalPosition = targetCamera.position.clone(); // 원래 위치 저장
        }

        function updateScreenShake(targetCamera, delta) {
            if (shake.elapsed < shake.duration) {
                shake.elapsed += delta;
                const progress = shake.elapsed / shake.duration;
                const offset = shake.intensity * (1 - progress);

                targetCamera.position.x = targetCamera.userData.originalPosition.x + (Math.random() * 2 - 1) * offset;
                targetCamera.position.y = targetCamera.userData.originalPosition.y + (Math.random() * 2 - 1) * offset;
                targetCamera.position.z = targetCamera.userData.originalPosition.z + (Math.random() * 2 - 1) * offset;
            } else if (targetCamera.userData.originalPosition) {
                // 흔들림 끝나면 원래 위치로 복귀
                targetCamera.position.copy(targetCamera.userData.originalPosition);
                delete targetCamera.userData.originalPosition;
            }
        }


        // --- 9. 게임 루프 ---
        let prevTime = performance.now();

        function animate() {
            requestAnimationFrame(animate);

            const time = performance.now();
            const delta = (time - prevTime) / 1000;

            if (controls.isLocked === true) {
                // 감속 (마찰력)
                velocity.x -= velocity.x * 10.0 * delta;
                velocity.z -= velocity.z * 10.0 * delta;
                velocity.y -= 9.8 * 50.0 * delta; // 중력 강화

                direction.z = Number(moveForward) - Number(moveBackward);
                direction.x = Number(moveRight) - Number(moveLeft);
                direction.normalize(); // 대각선 이동 속도 일정하게

                if (moveForward || moveBackward) velocity.z -= direction.z * 200.0 * delta; // 이동 속도 조정
                if (moveLeft || moveRight) velocity.x -= direction.x * 200.0 * delta;

                controls.moveRight(-velocity.x * delta);
                controls.moveForward(-velocity.z * delta);

                controls.getObject().position.y += (velocity.y * delta);

                // 바닥 충돌 및 점프 가능 여부
                if (controls.getObject().position.y < playerHeight) {
                    velocity.y = 0;
                    controls.getObject().position.y = playerHeight;
                    canJump = true;
                }

                // 맵 경계 충돌 (간단한 처리)
                const playerPos = controls.getObject().position;
                const mapLimit = 145; // 맵의 절반 크기 (경계 벽 안쪽)
                playerPos.x = Math.max(-mapLimit, Math.min(mapLimit, playerPos.x));
                playerPos.z = Math.max(-mapLimit, Math.min(mapLimit, playerPos.z));

                // 오브젝트 충돌 감지 (간단한 Box-Box 충돌)
                // 현재는 플레이어 이동 후 위치를 조정하는 방식이므로, 정밀한 충돌은 더 복잡한 로직 필요
            }
            
            // 적들 회전 (생동감)
            enemies.forEach(enemy => {
                enemy.rotation.y += 0.02;
            });

            updateExplosions(delta); // 폭발 파티클 업데이트
            updateScreenShake(camera, delta); // 화면 흔들림 업데이트
            updateUI(); // UI는 매 프레임 업데이트

            prevTime = time;
            renderer.render(scene, camera);
        }

        // 윈도우 리사이즈 대응
        window.addEventListener('resize', function () {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // 초기 UI 업데이트
        updateUI();
        animate();
    </script>
</body>
</html>
